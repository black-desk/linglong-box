@startuml ll-box

actor user
participant "cli / library" as cli
participant monitor

box "rootfs namespaces"
participant "rootfs preparer" as rootfs
end box

box "container namespaces"
participant init
participant app
end box

user -> cli: run "create"
activate cli
cli -> cli: parse config.json
cli -> cli: update state

==creating==

cli -> monitor: fork
activate monitor
monitor -> monitor: create systemd scope
monitor -> monitor: prctl **PR_SET_CHILD_SUBREAPER**
monitor -> monitor: setup signal handler
monitor ->> rootfs: clone
activate rootfs

group config rootfs userns
monitor <- rootfs: requset write ID mapping
monitor -> monitor: setup ID mapping
monitor --> rootfs: done
end

group prepare rootfs
rootfs -> rootfs: do native mounts
rootfs -> rootfs: maybe setup fuse
rootfs -> rootfs: setup dbus-proxy
end


rootfs -> init: clone
activate init

group config container userns
rootfs <- init: requset write ID mapping
rootfs -> rootfs: setup ID mapping
rootfs --> init: done
end

deactivate rootfs

init -> init: setup container
init -> init: setup signal handler
cli <-- init: "create" result
cli -> cli: update state
==created==

cli -> monitor: request run hooks

monitor -> monitor: run "prestart"
monitor -> monitor: run "createRuntime"
monitor -> init: requset run hooks
init -> init: run "createContainer"
init->init: start listen socket
init -> init: `pivot_root`
monitor <-- init: "hooks" result
cli <-- monitor: "hooks" result
user <-- cli: done
deactivate cli

user -> cli: run "start"
activate cli
cli -> init: "start" over unix socket
init -> init: run "startContainer"
init -> init: setup signal handler
init ->> app: fork & exec

activate app
init -> monitor : request run hooks
monitor -> monitor: run "poststart"
monitor --> init: "hooks" result
cli <-- init: "start & hooks" result

note over monitor, init
exec self to clear memory
&& setup signal handler
endnote

cli -> cli: update state

==running==

user <-- cli: done
deactivate cli

user -> cli: run "exec"
activate cli
cli -> init: request "exec" over socket
init ->> app: fork & exec
activate app
init <-- app: exit
deactivate app
cli <-- init: "exec" result
user <-- cli: done
deactivate cli

user -> cli: run "kill"
activate cli
cli -> init: kill
init -> app: kill
init <-- app: exit
deactivate app
note left
all child exit
endnote
cli <-- init: exit
deactivate init
cli -> cli: update state
==stopped==
user <-- cli: done
deactivate cli


user -> cli: run "delete"
activate cli
cli -> monitor: terminate
monitor -> monitor: run "poststop"
monitor -> monitor: release rootfs
cli <-- monitor: exit
deactivate monitor
cli -> cli: update state
user <-- cli: done
deactivate cli

@enduml